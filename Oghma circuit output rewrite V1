# Import modules python3.12.2

from pathlib import Path
import pandas as pd
import json
import matplotlib.pyplot as plt
import numpy as np
from scipy.optimize import curve_fit
from scipy import interpolate
from scipy.interpolate import LSQUnivariateSpline
import re
import plotly.express as px

model_version = 'Model V19-1' 

# device area [m^2]
A = 0.00000121	         

# Type path to folder here (Mac/Windows/Unix compatible):
sim_folder = "/Users/alexiarango/Documents/Oghma/Circuit V19/V19-1/circuit_v19 c60 40nm d14 up/"

# Windows or Mac machine?
Mac = True

# List names of circuit elements to plot:
elements = ['Rs', 'Rc', 'Rb', 'Rsh']

# List names of circuit sub-elements to plot:
sub_elements = ['St', 'Tt']


'''
Set plotting attributes
'''

black_background = True

plot_slopes = True

noise_threshold = 0.4

plot_width = 7
plot_height = 9
dpi = 120

line_color = 'white'
data_color = 'darkcyan'
point_color = (0.8, 0.8, 0)
fit_color = 'deeppink'
elements_line_color = 'gray'
linewidth = 2

write_model_version = False
write_parameter_data_df = False




'''
Open raw jv data file and create numpy array
'''

if Mac == True:
    files = Path(sim_folder)
else: 
  sim_folder = sim_folder.replace('\\','/')
  files = Path(sim_folder)

print(files)


data_raw = pd.read_csv(files / "fit_data0.inp", sep="\t", skiprows=1, header=None)
data_raw = data_raw.loc[(data_raw!=0).any(axis=1)]
v_data = data_raw[data_raw.columns[0]].to_numpy()
j_data = data_raw[data_raw.columns[1]].to_numpy()

# Eliminate first data point if errant
if v_data[0] < 1e-10:
  v_data = np.delete(v_data, [0])
  j_data = np.delete(j_data, [0])



''''
Extract current and voltage drops across circuit elements from netlist folders
'''

# Generate list of folder paths in netlist folder
netlist = files / "netlist/"
folders = list(netlist.glob('*/'))


# Iterate through each folder and read circuit_labels.dat files

#create empty DataFrame
data_df = pd.DataFrame()

#iterate over list with length = number of folders
for x in range(len(folders)):

  #get folder name, step number
  step = int(folders[x].name)
    
  #do not use .DS_Store file
  if step == ".DS_Store" or step == "results" or step == "data.json":
      continue

  temp = pd.DataFrame()

  #Read circuit_labels into DataFrame
  temp = pd.read_json(folders[x] / "circuit_labels.dat")

  #open data.json file
  with open(folders[x] / "data.json", 'r') as f:
    folder_data = json.load(f)

  # get voltage from data.json
  voltage = folder_data['voltage']

  # create list of voltages
  voltage_list = [voltage] * len(temp.columns)
  
  
  
  # append new voltage row to temp
  temp.loc['voltage'] = voltage_list

  #append new rows to DataFrame
  data_df = pd.concat([data_df, temp])

# Transpose DataFrame
#data_df.sort_index(axis=0,kind='stable',inplace=True)

# drop extra segments column
data_df = data_df.drop(columns=['segments'])





'''
Determine circuit element titles based on uid and replace segment column titles
'''

# find uid data_df
uid=data_df.iloc[1].to_list()

# turn circuit_labels uid into sim.json segment#
segments=[]
for x in uid:
	segments.append(f"segment{x}")

# open sim.json and find segment names
myfile = open(files / 'sim.json')
sim = json.load(myfile)
titles=[]
for x in segments:
	titles.append(sim['circuit']['circuit_diagram'][x]['name'])
myfile.close()


# rename dataframe columns
for i, column in enumerate(data_df.columns):
	data_df = data_df.rename(columns={column: titles[i]})


pd.set_option('display.max_columns', None)
print(data_df)


'''
Set up ploting
'''

# Create figure
if black_background == True:
  plt.style.use('dark_background')							#black background

if plot_slopes == True:
  fig, (axs0, axs1) = plt.subplots(2, 
                                   1, 
                                   sharex=True, 
                                   figsize=(plot_width, 
                                            plot_height), 
                                   gridspec_kw={'height_ratios':[1,0.5]}, 
                                   dpi=dpi)
  
  #adjust plot margins
  fig.subplots_adjust(top=0.995, right=0.99, bottom=0.055, left=0.11, hspace=0)
  
else:
  fig, axs0 = plt.subplots(1, 1, sharex=True, figsize=(plot_width, plot_height), dpi=dpi, layout='constrained')

# Set title
fig.canvas.manager.set_window_title(files.name + " " + str(i)) 

# Set up iv plot
axs0.set_ylabel("Current density [A/m$^2$]")
axs0.set_xscale("log")
axs0.set_yscale("log")

# Label axes
if plot_slopes == True:
  axs1.set_ylabel("Slope of log-log j-v curve")
  axs1.set_xlabel("Voltage [V]")

else:
    axs0.set_xlabel("Voltage [V]")


if write_model_version == True:
  
  #text box for model version
  axs0.text(0.98, 0.025, model_version, transform=axs0.transAxes, ha='right')		

if write_parameter_data_df == True:
  
  # remove column names from string
  circuit_parameters_temp = circuit_parameters_df.to_string()
  rows = circuit_parameters_temp.split('\n')
  rows.pop(0)
  circuit_parameters_string = '\n'.join(rows)
  
  # Add table of circuit parameters to plot
  axs0.text(0.02, 0.98, 
              circuit_parameters_string,   
              transform=axs0.transAxes, ha='left', va='top')
            

'''
Find slopes
'''





'''
Add data to plot
'''

# Add raw data to iv plot
axs0.plot(v_data, j_data, linewidth=0, color=point_color, marker='o', markersize=1)

# find voltage
voltage = data_df.loc['voltage', data_df.columns[0]].values
voltage = np.sort(voltage)
voltage = np.array(voltage, dtype=float)


# add fit to plot
columns_to_plot = elements

for i in range(len(columns_to_plot)):
    current_df = data_df.loc['i', columns_to_plot[i]]
    current = current_df.values / A
    current = np.sort(current)
    axs0.plot(voltage,
              current,
              color = line_color,
              linewidth=linewidth/5)
    
columns_to_plot = sub_elements
    
for i in range(len(columns_to_plot)):
    current_df = data_df.loc['i', columns_to_plot[i]]
    current = current_df.values / A
    current = np.sort(current)
    axs0.plot(voltage,
              current,
              color = line_color,
              linewidth=linewidth/10)



# Add slope data to iv plot
if plot_slopes == True:
  
  # calculate slope of data
  j_data_slope = np.gradient(np.log10(j_data), 
                             np.log10(v_data), edge_order=2)
  
  # plot slope of data
  axs1.plot(v_data, j_data_slope, linewidth=0, color=point_color, marker='o', markersize=1)

  # add slope of fits to plot
  columns_to_plot = elements

  for i in range(len(columns_to_plot)):
      current_df = data_df.loc['i', columns_to_plot[i]]
      current = current_df.values / A
      current = np.sort(current)
      current_np = np.array(current, dtype=float)
      slope = np.gradient(np.log10(current_np), np.log10(voltage), edge_order=2)
      axs1.plot(voltage,
                slope,
                color = line_color,
                linewidth=linewidth/5)
      
  columns_to_plot = sub_elements

  for i in range(len(columns_to_plot)):
      current_df = data_df.loc['i', columns_to_plot[i]]
      current = current_df.values / A
      current = np.sort(current)
      current_np = np.array(current, dtype=float)
      slope = np.gradient(np.log10(current_np), np.log10(voltage), edge_order=2)
      axs1.plot(voltage,
                slope,
                color = line_color,
                linewidth=linewidth/10)





'''
Set axis limits
'''

axs0.set_xlim(
              v_data[0],
              v_data[-1]
)

axs0.set_ylim(			
                j_data.min()*0.1,			# grab min from data
                j_data.max()*2				# grab max from data
)

if plot_slopes == True:

  # Find index above noise threshold
  noise_threshold_index = min(range(len(v_data)), key=lambda i: abs(v_data[i] - noise_threshold))
  
  axs1.set_ylim(			
                0.5,
                np.max(j_data_slope[noise_threshold_index :])*1.1				# grab max from data
  )



plt.show()

# Add spline
#axs0.plot(v_data_masked, jv_spline(v_data_masked), linewidth=linewidth, color=data_color)

