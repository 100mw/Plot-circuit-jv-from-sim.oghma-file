# -*- coding: utf-8 -*-
"""
Created on Thu Feb  9 15:37:57 2023

@author: aarango
"""

#!/usr/bin/env python3

from pathlib import Path
import pandas as pd
import json
import matplotlib.pyplot as plt
import numpy as np
from scipy.optimize import curve_fit
from scipy import interpolate
from scipy.interpolate import LSQUnivariateSpline
import re


# Type path to folder here (Mac/Windows/Unix compatible):

#files = Path(
# "/Users/alexiarango/Documents/Oghma/Circuit V15/circuit_v15 c60 40nm d14 down/"
#)

files = Path(
  "/Users/alexiarango/Downloads/JV trap limited 06232023 1_2/"
)

## Windows:
#files = Path(
# "C:/Users/aarango/Documents/circuit_v12-3 c60 30nm d10 up"
#)


# Set global constants here:

A = 0.00000121	          # device area
k = 8.617333262e-5		    # Boltzmann constant
T = 300					          # temperature
#epsilon0 = 8.854e-12      # permitivity of free space in F/m
#epsilon_C60 = 2.3         # dielectric constant of C60
#epsilon_MoO3 = 35
#thickness_MoO3 = 10


'''
Set plotting attributes
'''

slope_smoothing = 1.1
curvature_smoothing = 3
mask_error_voltage = 0.2

black_background = True
dpi=170
line_color = 'white'
data_color = 'darkcyan'
point_color = (0.8, 0.8, 0)
fit_color = 'deeppink'
elements_line_color = 'gray'
linewidth = 1

plot_slopes = True
plot_voltage_curves = False
plot_effective_voltage = False 

write_model_version = True
write_parameter_values = True

plot_Vbi_point = True
plot_Vo_point = True
plot_Vr_point = True

plot_width = 6
plot_height = 8.3

show_circuit_legs = 5
fill_under_curve = 0

model_version = 'Model V13-9'

save_fit_branches = True


'''
Open raw data file
'''

data_raw = pd.read_csv(files / "fit_data0.inp", sep="\t", skiprows=1, header=None)
data_raw = data_raw.loc[(data_raw!=0).any(axis=1)]
v_data = data_raw[data_raw.columns[0]].to_numpy()
j_data = data_raw[data_raw.columns[1]].to_numpy()

# Eliminate first data point if errant
if v_data[0] < 1e-10:
  v_data = np.delete(v_data, [0])
  j_data = np.delete(j_data, [0])
  


''''
Extract voltage drops across circuit elements
'''

# Generate list of folder paths in netlist folder
netlist = files / "netlist/"
folders = list(netlist.glob('*/'))
#print(folders)

# Iterate through each folder and read circuit_labels.dat files

#create empty DataFrame
values = pd.DataFrame()

#iterate over list with length = number of folders
for x in range(len(folders)):
  
  #get folder name, step number
	step = folders[x].name
  
  #do not use .DS_Store file
	if step == ".DS_Store" or step == "results" or step == "data.json":
		continue
  
	temp = pd.DataFrame()
  
  #Read circuit_labels into DataFrame
	temp = pd.read_json(folders[x] / "circuit_labels.dat")
  
  #Calculate v0-v1, label row with step number as integer
	temp.loc[int(step)] = temp.loc['v0'] - temp.loc['v1']
  
  #Delete other rows
	temp.drop(['com', 'uid', 'i', 'v0', 'v1'], inplace=True)
  
  #rename "segments" column
	temp.rename(columns={'segments':'Voltage [V]'}, inplace=True)
  
  #open data.json file
	with open(folders[x] / "data.json", 'r') as f:
		data = json.load(f)
    
  #get voltage from data.json and write to temp DataFrame
	temp.at[int(step), 'Voltage [V]'] = data['voltage']
  
  #append new row to DataFrame
	values = pd.concat([values, temp])

# Sort DataFrame
values.sort_index(axis=0,kind='stable',inplace=True)

# Rename DataFrame columns
values.rename(columns={
	'segment0' :  'D',
	'segment1' :  'Rsh',
	'segment2' :  'Bd',
	'segment3' :  'Bsh',
	'segment4' :  'Tsh',
	'segment5' :  'Ts',
	'segment6' :  'Ip',
	'segment7' :  'Rs',
  'segment8' :  'SC'
  }, inplace=True)

# Turn columns into numpy arrays
v = values['Voltage [V]'].to_numpy(dtype=float)
Diode_volt_drop = values['D'].to_numpy(dtype=float)
Rsh_volt_drop = values['Rsh'].to_numpy(dtype=float)
block_diode_volt_drop = values['Bd'].to_numpy(dtype=float)
Ts_volt_drop = values['Ts'].to_numpy(dtype=float)
#Ts_volt_drop[Ts_volt_drop  == 0] = 0.0000001
Ip_volt_drop = values['Ip'].to_numpy(dtype=float)
block_shunt_volt_drop = values['Bsh'].to_numpy(dtype=float)
#block_shunt_volt_drop[block_shunt_volt_drop == 0] = np.nan
Tsh_volt_drop = values['Tsh'].to_numpy(dtype=float)
Rs_volt_drop = values['Rs'].to_numpy(dtype=float)
Rs_volt_drop[Rs_volt_drop  == 0] = np.nan
SC_volt_drop = values['SC'].to_numpy(dtype=float)



'''''
Fit voltage voltage drop data
'''''

Vbi_guess = 0.5
diode_width_guess = 0.5

Vo_guess = 1.5
Ip_width_guess = 0.2
Ip_n_guess = 1

Vr_guess = 2			
Rs_width_guess = 0.2
Rs_n_guess = 1

# Define Diode voltage drop function
def Diode_func(x, Vbi_fit, diode_width):
#  return Vbi_fit*(1-np.exp(-x/diode_width))
  return x-diode_width*np.log(np.exp((x-Vbi_fit)/diode_width)+1)

# Fit Diode voltage drop
fit_diode_params, diode_pcov = curve_fit(Diode_func, 
                                    v, 
                                    Diode_volt_drop, 
                                    p0=[Vbi_guess, diode_width_guess], 
                                    method='lm')

#standard deviation of errors
perr_diode = np.sqrt(np.diag(diode_pcov))

# Define Inj voltage drop function
def Ip_func(x, Vo_fit, Ip_width, Ip_n):
  return x-Ip_width*np.log(np.exp((x-Vo_fit)/Ip_n/Ip_width)+1)

# Fit Inj voltage drop
fit_Inj_params, Inj_pcov = curve_fit(Ip_func, 
                                      v, 
                                      Ip_volt_drop, 
                                      p0=[ Vo_guess, 
                                            Ip_width_guess,
                                            Ip_n_guess], method='lm')
    
#standard deviation of errors
perr_Inj = np.sqrt(np.diag(Inj_pcov))		  		 

# Define Rs voltage drop function
def VRs_func(x, Vr_fit, Rs_width, Rs_n):
  return Rs_width*np.log(np.exp((x-Vr_fit)/Rs_n/Rs_width)+1)

# Fit Rs voltage drop
fit_Rs_params, Rs_pcov = curve_fit(VRs_func, 
                              v, 
                              Rs_volt_drop,
                              p0=[Vr_guess, Rs_width_guess, Rs_n_guess], 
                              method='lm')
                            
perr_Rs = np.sqrt(np.diag(Rs_pcov))	

fit_params = np.concatenate((fit_diode_params, fit_Inj_params, fit_Rs_params))
perr = np.concatenate((perr_diode, perr_Inj, perr_Rs))

# Create DataFrame
fit_volt_results_df = pd.DataFrame(index = ['Vbi', 
                                    'diode width', 
                                    'Vo', 
                                    'Ip_width', 
                                    'Ip_n', 
                                    'Vr', 
                                    'Rs_width', 
                                    'Rs_n'])
fit_volt_results_df['Value'] = fit_params
#fit_results['Error'] = perr


Vbi_fit_result = fit_diode_params[0]
Vo_fit_result = fit_Inj_params[0]
Vr_fit_result = fit_Rs_params[0]

  
  
  

'''
Read circuit element parameters from sim.oghma 
'''

# Create list of segments to search
numbers = list(range(0,35))
numbers_str = [str(numbers[i]) for i in range(len(numbers))]

segment = []
for i in range(len(numbers)):
  segment.append("segment")
  
segments = [segment[i] + numbers_str[i] for i in range(len(segment))]

# Open sim file
myfile = open(files / 'sim.json')
sim = json.load(myfile)
circuit = sim["circuit"]
circuit_diagram = circuit["circuit_diagram"]
for i in range(len(segments)):
  if circuit_diagram[segments[i]]['name'] == 'Jdiode':
    Jo = circuit_diagram[segments[i]]['I0']
    n = circuit_diagram[segments[i]]['nid']
  if circuit_diagram[segments[i]]['name'] == 'block_diode':
    JoBd = circuit_diagram[segments[i]]['I0']
    bd = circuit_diagram[segments[i]]['c']
    Bd_Vo = circuit_diagram[segments[i]]['a']
    Bd_d = circuit_diagram[segments[i]]['b']
  if circuit_diagram[segments[i]]['name'] == 'Rsh':
    Rsh = circuit_diagram[segments[i]]['R']
  if circuit_diagram[segments[i]]['name'] == 'shunt':
    JoTsh = circuit_diagram[segments[i]]['I0']
    tsh = circuit_diagram[segments[i]]['c']
    Tsh_Vo = circuit_diagram[segments[i]]['a']
    Tsh_d = circuit_diagram[segments[i]]['b']
  if circuit_diagram[segments[i]]['name'] == 'block_shunt':
    JoBsh = circuit_diagram[segments[i]]['I0']
    bsh = circuit_diagram[segments[i]]['c']
    Bsh_Vo = circuit_diagram[segments[i]]['a']
    Bsh_d = circuit_diagram[segments[i]]['b']
  if circuit_diagram[segments[i]]['name'] == 'series':
    JoTs = circuit_diagram[segments[i]]['I0']
    ts = circuit_diagram[segments[i]]['c']
    Ts_Vo = circuit_diagram[segments[i]]['a']
    Ts_d = circuit_diagram[segments[i]]['b']
  if circuit_diagram[segments[i]]['name'] == 'Injection':
    JoIp = circuit_diagram[segments[i]]['I0']
    ip = circuit_diagram[segments[i]]['c']
    Ip_Vo = circuit_diagram[segments[i]]['a']
    Ip_d = circuit_diagram[segments[i]]['b']
  if circuit_diagram[segments[i]]['name'] == 'SC':
    JoSC = circuit_diagram[segments[i]]['I0']
    sc = circuit_diagram[segments[i]]['c']
    SC_Vo = circuit_diagram[segments[i]]['a']
    SC_d = circuit_diagram[segments[i]]['b']
  if circuit_diagram[segments[i]]['name'] == 'Rs':
    Rs = circuit_diagram[segments[i]]['R']
myfile.close()

circuit_parameters = [Rs,
                      JoSC,
                      sc,
                      JoTs,
                      ts,
                      JoIp,
                      ip,
                      JoBsh,
                      bsh,
                      JoTsh,
                      tsh,
                      JoBd,
                      bd,
                      Jo,
                      n,
                      Rsh
]

circuit_parameters_index = ['Rs',
                            'JoSC',
                            'sc',
                            'JoTs',
                            'ts',
                            'JoIp',
                            'ip',
                            'JoBsh',
                            'bsh',
                            'JoTsh',
                            'tsh',
                            'JoBd',
                            'bd',
                            'Jo',
                            'n',
                            'Rsh'
]

circuit_parameters_df = pd.DataFrame(data = circuit_parameters,
                                      index = circuit_parameters_index,
                                      columns = ['Value']
                                      )

# Display DataFrames as decimals or scientific notation
pd.options.display.float_format = '{:.3g}'.format






"""
Circuit functions - circuit elements
"""

Vbi = Tsh_Vo
Vo = Ip_Vo

# Ohmic shunt and dc offset
def Rshunt(Rsh):
    return Rsh_volt_drop/Rsh/A

#Ohmic series
def Rseries(Rs):
    return Rs_volt_drop/Rs/A

# ideal diode
def Diode(Jo, 
          n):
    return Jo*(np.exp(Diode_volt_drop/n/k/T)-1)/A

# effect of blocking layer on ideal diode
def block_Diode(JoBd, 
                bd):
  return np.power(JoBd*block_diode_volt_drop/Bd_d, bd)/A

#space charge transport (shunt)
def Tshunt(JoTsh, 
            tsh, 
            Vbi):
    return np.power(JoTsh*Tsh_volt_drop/(Vbi+Tsh_d), tsh)/A

#effect of blocking layer on transport (shunt)
def block_Tshunt(JoBsh, 
                bsh, 
                Vbi):
    return np.power(JoBsh*block_shunt_volt_drop/(Vbi+Bsh_d), bsh)/A

#Injection from p-type electrode
def Inj_p(JoIp, 
          ip, 
          Vo):
    return np.power(JoIp*Ip_volt_drop/(Vo+Ip_d), ip)/A

#space charge transport (series)
def Tseries(JoTs, 
            ts, 
            Vo):
    return np.power(JoTs*Ts_volt_drop/(Vo+Ts_d), ts)/A

#space charge transport (series)
def SC(JoSC, 
            sc, 
            Vo):
    return np.power(JoSC*SC_volt_drop/(Vo+SC_d), sc)/A





"""
Analytical circuit solutions
"""

def Rseries_fit(v,
                Rs,
                *fit_Rs_params):
  return VRs_func(v, *fit_Rs_params)/Rs/A

if show_circuit_legs > 3:
  def Jdark(Rsh, 
            Jo, 
            n, 
            JoTsh, 
            tsh, 
            JoIp, 
            ip, 
            Vbi, 
            Vo):
      return (Diode(Jo, n) 
                  + Tshunt(JoTsh, tsh, Vbi) 
                  + Inj_p(JoIp, ip, Vo) 
                  + Rshunt(Rsh))
                  
elif show_circuit_legs == 3:
    def Jdark(Rsh, 
            Jo, 
            n, 
            JoTsh, 
            tsh, 
            JoIp, 
            ip, 
            Vbi, 
            Vo):
      return (Diode(Jo, n) 
                  + Tshunt(JoTsh, tsh, Vbi)  
                  + Rshunt(Rsh))
                  
elif show_circuit_legs == 2:
    def Jdark(Rsh, 
            Jo, 
            n, 
            JoTsh, 
            tsh, 
            JoIp, 
            ip, 
            Vbi, 
            Vo):
      return (Diode(Jo, n) 
                  + Rshunt(Rsh))
                  
elif show_circuit_legs == 1:
    def Jdark(Rsh, 
            Jo, 
            n, 
            JoTsh, 
            tsh, 
            JoIp, 
            ip, 
            Vbi, 
            Vo):
      return (Rshunt(Rsh))

def Jdark_slope(Rsh, 
          Jo, 
          n, 
          JoTsh, 
          tsh, 
          JoIp,
          ip,
          Vbi, 
          Vo):
    return np.gradient(np.log10(Jdark(Rsh, 
                                      Jo, 
                                      n, 
                                      JoTsh, 
                                      tsh, 
                                      JoIp, 
                                      ip, 
                                      Vbi, 
                                      Vo)), np.log10(v))

def Jdark_curvature(Rsh, 
                    Jo, 
                    n, 
                    JoTsh, 
                    tsh, 
                    JoIp, 
                    ip, 
                    Vbi, 
                    Vo):
  return np.gradient(Jdark_slope(Rsh, 
                                Jo, 
                                n, 
                                JoTsh, 
                                tsh, 
                                JoIp,
                                ip,
                                Vbi, 
                                Vo), np.log10(v))




'''
Save fit curves
'''

if save_fit_branches == True:
  
  fit_legs = pd.DataFrame()
  fit_legs['Voltage [V]'] = v
  fit_legs['Rshunt [A/m^2]'] = Rshunt(Rsh)
  fit_legs['Diffusion [A/m^2]'] = Diode(Jo, n)
  fit_legs['Shunt [A/m^2]'] = Tshunt(JoTsh, tsh, Vbi)
  fit_legs['Injection [A/m^2]'] = Inj_p(JoIp, ip, Vo)
  fit_legs['Rseries [A/m^2]'] = Rseries(Rs)
  
  # path of new folder for results
  folderpath = files.parent / (files.stem + ' results')
  
  # make new folder
  folderpath.mkdir(parents=True, exist_ok=True)
  
  # check if file exits
  filename = Path(folderpath/'Fit legs .txt')
  i = 1
  while (new_filename := filename.with_stem(f"{filename.stem}{i}")).exists():
    i += 1
  
  # save curve
  fit_legs.to_csv(new_filename, sep='\t', index=False)
  
  print('Fit legs saved')
  
  



'''''
Find splines, slopes and curvatures
'''''

# Function to test if data is linear
def is_linear(arr):
  linspace_arr = np.linspace(arr[0], arr[-1], len(arr))
  return np.all(np.isclose(arr, linspace_arr, rtol=1e-1, atol=1e-3))

# Create an array of knots for splines
if is_linear(v_data) == False:
  slope_knots = np.logspace(np.log10(v_data.min()), 
                            np.log10(v_data.max()), 
                            int(v_data.size/slope_smoothing))
                          
  curvature_knots = np.logspace(np.log10(v_data.min()), 
                                np.log10(v_data.max()), 
                                int(v_data.size/curvature_smoothing))
else:
  slope_knots = np.linspace(v_data.min(), 
                            v_data.max(), 
                            int(v_data.size/slope_smoothing))

  curvature_knots = np.linspace(v_data.min(), 
                                v_data.max(), 
                                int(v_data.size/curvature_smoothing))

# Delete boundary knots
slope_knots = np.delete(slope_knots, [0,-1])
curvature_knots = np.delete(curvature_knots, [0,-1])

# Take spline of current
jv_spline = LSQUnivariateSpline(v_data, j_data, k=5, t=slope_knots)

# Find slopes
jv_slope = np.gradient(np.log10(j_data), 
                       np.log10(v_data), edge_order=2)
                      
Diode_slope = np.gradient(np.log10(Diode(Jo, n)), 
                          np.log10(v), edge_order=2)
                        
Tshunt_slope = np.gradient(np.log10(Tshunt(JoTsh, tsh, Vbi)), 
                           np.log10(v), edge_order=2)
                          
Inj_slope = np.gradient(np.log10(Inj_p(JoIp, ip, Vo)), 
                        np.log10(v), edge_order=2)
                      
Tseries_slope = np.gradient(np.log10(Tseries(JoTs, ts, Vo)), 
                            np.log10(v), edge_order=2)
                          
SC_slope = np.gradient(np.log10(SC(JoSC, sc, Vo)), 
                       np.log10(v), edge_order=2)
                      
Rseries_fit_slope = np.gradient(np.log10(Rseries_fit(v, Rs, *fit_Rs_params)), 
                                np.log10(v), edge_order=2)

# Take spline of slope
jv_slope_spline = LSQUnivariateSpline(v_data, jv_slope, k=5, t=slope_knots)

# Find curvatures
jv_curvature = np.gradient(jv_slope, np.log10(v_data), edge_order=2)
Diode_curvature = np.gradient(Diode_slope, np.log10(v), edge_order=2)
Tshunt_curvature = np.gradient(Tshunt_slope, np.log10(v), edge_order=2)
Inj_curvature = np.gradient(Inj_slope, np.log10(v), edge_order=2)
Tseries_curvature = np.gradient(Tseries_slope, np.log10(v), edge_order=2)
SC_curvature = np.gradient(SC_slope, np.log10(v), edge_order=2)
Rseries_fit_curvature = np.gradient(Rseries_fit_slope, np.log10(v), edge_order=2)

# Take spline of curvature
jv_curvature_spline = LSQUnivariateSpline(v_data, jv_curvature, k=5, t=curvature_knots)





'''
Calculate error
'''

# Mask voltages below specificied value
mask = v >= mask_error_voltage
v_masked = v[mask]
mask_data = v_data >= mask_error_voltage
v_data_masked = v_data[mask_data]

# Mask Jdark
Jdark_array = Jdark(Rsh, 
                    Jo, 
                    n, 
                    JoTsh, 
                    tsh, 
                    JoIp, 
                    ip, 
                    Vbi, 
                    Vo)
Jdark_masked = Jdark_array[mask]

# Mask Jdark_slope
Jdark_slope_array = Jdark_slope(Rsh, 
                    Jo, 
                    n, 
                    JoTsh, 
                    tsh, 
                    JoIp, 
                    ip, 
                    Vbi, 
                    Vo)
Jdark_slope_masked = Jdark_slope_array[mask]

# Current density error
Jdark_error = np.mean(
                      np.power(
                                np.log10(jv_spline(v_masked))
                              - np.log10(Jdark_masked), 2))

# Slope error
Jdark_slope_error = np.mean(
                            np.power(
                                    np.log10(jv_slope_spline(v_masked))
                                  - np.log10(Jdark_slope_masked), 2))

# Create DataFrame

error_results_df = pd.DataFrame({'Value': [Jdark_error, Jdark_slope_error]},
                                index = ['jv_error', 'slope_error']
)



"""
Plotting
"""

# Create figure
if black_background == True:
  plt.style.use('dark_background')							#black background

if plot_slopes == True:
  fig, (axs0, axs1, axs2) = plt.subplots(3, 1, sharex=True, figsize=(plot_width, plot_height), dpi=dpi)
  
  #adjust plot margins
  fig.subplots_adjust(top=0.995, right=0.99, bottom=0.055, left=0.11, hspace=0)
  
else:
  fig, axs0 = plt.subplots(1, 1, sharex=True, figsize=(plot_width, plot_height), dpi=dpi, layout='constrained')

fig.canvas.manager.set_window_title(files.name + " " + str(i)) 

# Set up iv plot
axs0.set_ylabel("Current density [A/m$^2$]")
axs0.set_xscale("log")
axs0.set_yscale("log")

if plot_slopes == False:
  axs0.set_xlabel("Voltage [V]")  

# Add raw data to iv plot
axs0.plot(v_data, j_data, linewidth=0, color=point_color, marker='o', markersize=1)

# Add fit (sum of legs)
Jdark_line, = axs0.plot(v, 
                            Jdark(Rsh, Jo, n, JoTsh, tsh, JoIp, ip, Vbi, Vo),
                              linewidth=linewidth, c=fit_color, label='Fit')
axs0.fill_between(v, 
                  j_data.min()*0.1, 
                  Jdark(Rsh, Jo, n, JoTsh, tsh, JoIp, ip, Vbi, Vo),  
                  color='yellow', 
                  alpha = fill_under_curve)

# Add spline
axs0.plot(v_data_masked, jv_spline(v_data_masked), linewidth=linewidth, color=data_color)

# set axis limits

axs0.set_xlim(
              v[0],
              v[-1]
)

axs0.set_ylim(			
                j_data.min()*0.1,			# grab min from data
                j_data.max()*2				# grab max from data
)

if write_model_version == True:
  
  #text box for model version
  axs0.text(0.98, 0.025, model_version, transform=axs0.transAxes, ha='right')		

if write_parameter_values == True:
  
  # remove column names from string
  circuit_parameters_temp = circuit_parameters_df.to_string()
  rows = circuit_parameters_temp.split('\n')
  rows.pop(0)
  circuit_parameters_string = '\n'.join(rows)
  
  # Add table of circuit parameters to plot
  axs0.text(0.02, 0.025, 
              circuit_parameters_string,   
              transform=axs0.transAxes, ha='left')
            
  # text box for jv error
  axs0.text(0.5, 0.025, 'Error = ' + "{:.3e}".format(Jdark_error), transform=axs0.transAxes, ha='center')





'''''
Prepare slope plot
'''''
  
if plot_slopes == True:

  # Set up slope plot
  #axs1.set_xlabel("Voltage [V]")
  axs1.set_ylabel("Slope of log-log j-v curve")
  #axs1.set_yscale("log")
  
  
  # set axis limits
  
  # Find index above Vbi
  nearest_Vbi_index = min(range(len(v_data)), key=lambda i: abs(v_data[i] - Vbi + 0.3))
    
  # Find max/min values only above Vbi
  axs1.set_ylim(			
                0.9,
                1.15*np.nanmax(jv_slope[nearest_Vbi_index :])  
  )
  
  axs2.set_ylim(
                  1.15*np.nanmin(jv_curvature[nearest_Vbi_index :]),
                  1.15*np.nanmax(jv_curvature[nearest_Vbi_index :])  
  )
  
  print(np.nanmax(jv_curvature[nearest_Vbi_index :]))
  
  # Add gradient of raw data to slope plot
  axs1.plot(v_data, jv_slope, linewidth=0, color=point_color, marker='o', markersize=1)
  
  # Add fit to slope plot
  axs1.plot(v, 
              Jdark_slope(Rsh, Jo, n, JoTsh, tsh, JoIp, ip, Vbi, Vo), 
              linewidth=linewidth, c=fit_color, label='Fit')
  
  # Add spline to slope plot
  axs1.plot(v_data_masked, jv_slope_spline(v_data_masked), linewidth=linewidth, color=data_color)
    
  # Prepare curvature plot
  
  # Set up curvature plot
  axs2.set_xlabel("Voltage [V]")
  axs2.set_ylabel("Curvature of log-log j-v curve")
  
  # Add gradient of raw data to curvature plot as points
  axs2.plot(v_data, jv_curvature, linewidth=0, color=point_color, marker='o', markersize=1)
  
  # Add fit to curvature plot
  axs2.plot(v,
            Jdark_curvature(Rsh, Jo, n, JoTsh, tsh, JoIp, ip, Vbi, Vo), 
            linewidth=linewidth, c=fit_color, label='Fit')
  
  # Add data to curvature plot
  axs2.plot(v_data_masked, jv_curvature_spline(v_data_masked), linewidth=linewidth, color=data_color)
  #axs2.plot(v_data, jv_spline_gradient2, linewidth=linewidth, color='orange')
  
  
  if write_parameter_values == True:
    
    # remove column names from string
    fit_results_string_temp = fit_volt_results_df.to_string()
    rows = fit_results_string_temp.split('\n')
    rows.pop(0)
    rows.pop(1)
    rows.pop(2)
    rows.pop(2)
    rows.pop(3)
    rows.pop(3)
    fit_results_string = '\n'.join(rows)
    
    # Add table of votages to plot
    axs1.text(0.02, 0.8, 
                fit_results_string,   
                transform=axs1.transAxes, ha='left')
              
    # text box for jv slope error
    axs1.text(0.5, 0.025, 'Error = ' + "{:.3e}".format(Jdark_slope_error), transform=axs1.transAxes, ha='center')
   
    
'''''
Add voltage points to plot
'''''
    
if (plot_Vbi_point == True or 
    plot_Vo_point == True or
    plot_Vr_point == True):

  # Interpolate
  fint_Jdark = interpolate.interp1d(v, Jdark(Rsh, Jo, n, JoTsh, tsh, JoIp, ip, Vbi, Vo), kind = 'linear')
  
  # Plot points
  if plot_Vbi_point == True:
    axs0.plot(Vbi_fit_result, fint_Jdark(Vbi_fit_result), marker='o', fillstyle='none', markersize=4, c='white', markeredgewidth=0.5)
    Vbi_text = axs0.text(Vbi_fit_result*np.power(10,-0.01), 
                          fint_Jdark(Vbi_fit_result)*np.power(10, plot_height/30), '$V_{bi}$', ha='right')
  if plot_Vo_point == True:
    axs0.plot(Vo_fit_result, fint_Jdark(Vo_fit_result), marker='o', fillstyle='none', markersize=4, c='white', markeredgewidth=0.5)
    Vo_text = axs0.text(Vo_fit_result*np.power(10,-0.01), 
                        fint_Jdark(Vo_fit_result)*np.power(10, plot_height/30), '$V_{0}$', ha='right')
  if plot_Vr_point == True:
    axs0.plot(Vr_fit_result, fint_Jdark(Vr_fit_result), marker='o', fillstyle='none', markersize=4, c='white', markeredgewidth=0.5)
    Vr_text = axs0.text(Vr_fit_result*np.power(10,-0.01), 
                        fint_Jdark(Vr_fit_result)*np.power(10, plot_height/30), '$V_{r}$', ha='right')
    
  if plot_slopes == True:
    
    # Interpolate slope
    fint_Jdark_slope = interpolate.interp1d(v, Jdark_slope(Rsh, Jo, n, JoTsh, tsh, JoIp, ip, Vbi, Vo), kind = 'linear')
    
    # Plot slope points
    if plot_Vbi_point == True:
      axs1.plot(Vbi_fit_result, fint_Jdark_slope(Vbi_fit_result), marker='o', fillstyle='none', markersize=4, c='white', markeredgewidth=0.5)
      Vbi_text = axs1.text(Vbi_fit_result*np.power(10,-0.02), 
                          fint_Jdark_slope(Vbi_fit_result) + plot_height/30, '$V_{bi}$', ha='right')
    if plot_Vo_point == True:
      axs1.plot(Vo_fit_result, fint_Jdark_slope(Vo_fit_result), marker='o', fillstyle='none', markersize=4, c='white', markeredgewidth=0.5)
      Vo_text = axs1.text(Vo_fit_result*np.power(10,0.02), 
                          fint_Jdark_slope(Vo_fit_result) + plot_height/30, '$V_{0}$', ha='left')
    if plot_Vr_point == True:
      axs1.plot(Vr_fit_result, fint_Jdark_slope(Vr_fit_result), marker='o', fillstyle='none', markersize=4, c='white', markeredgewidth=0.5)
      Vr_text = axs1.text(Vr_fit_result*np.power(10,0.02), 
                          fint_Jdark_slope(Vr_fit_result) + plot_height/30, '$V_{r}$', ha='left')
      
    # Interpolate curvature
    fint_Jdark_curvature = interpolate.interp1d(v, Jdark_curvature(Rsh, Jo, n, JoTsh, tsh, JoIp, ip, Vbi, Vo), kind = 'linear')
    
    # Plot points
    if plot_Vbi_point == True:
      axs2.plot(Vbi_fit_result, fint_Jdark_curvature(Vbi_fit_result), marker='o', fillstyle='none', markersize=4, c='white', markeredgewidth=0.5)
      Vbi_text = axs2.text(Vbi_fit_result*np.power(10,-0.02), 
                          fint_Jdark_curvature(Vbi_fit_result) + plot_height/30, '$V_{bi}$', ha='right')
    if plot_Vo_point == True:
      axs2.plot(Vo_fit_result, fint_Jdark_curvature(Vo_fit_result), marker='o', fillstyle='none', markersize=4, c='white', markeredgewidth=0.5)
      Vo_text = axs2.text(Vo_fit_result*np.power(10,0.02), 
                          fint_Jdark_curvature(Vo_fit_result) + plot_height/30, '$V_{0}$', ha='left')
    if plot_Vr_point == True:
      axs2.plot(Vr_fit_result, fint_Jdark_curvature(Vr_fit_result), marker='o', fillstyle='none', markersize=4, c='white', markeredgewidth=0.5)
      Vr_text = axs2.text(Vr_fit_result*np.power(10,0.02), 
                          fint_Jdark_curvature(Vr_fit_result) + plot_height/30, '$V_{r}$', ha='left')
    



# Add individual circuit elements to iv plot

if show_circuit_legs > 0:
  Rshunt_line, = axs0.plot(v, 
    Rshunt(Rsh), 
    color=elements_line_color, linewidth=linewidth/1.5, linestyle='dotted')
  if show_circuit_legs > 1:
    axs0.plot(v, 
      Diode(Jo, n), 
      color=elements_line_color, linewidth=linewidth/1.5, linestyle='dashed')
    if show_circuit_legs > 2:
      axs0.plot(v, 
        Tshunt(JoTsh, tsh, Vbi), 
        color=elements_line_color, linewidth=linewidth/1.5, linestyle=(0,(1,1)))
      if show_circuit_legs > 3:
        axs0.plot(v, 
          Inj_p(JoIp, ip, Vo), 
          color=elements_line_color, linewidth=linewidth/1.5, linestyle='dashdot')
        if show_circuit_legs > 4:
          axs0.plot(v, 
            Tseries(JoTs, ts, Vo), 
            color=elements_line_color, linewidth=linewidth/2, linestyle=(2,(2,5,2)))
          axs0.plot(v, 
            SC(JoSC, sc, Vo), 
            color=elements_line_color, linewidth=linewidth/2, linestyle='dashdot')


#Rseries_line, = axs0.plot(v,
#  Rseries_fit(v, Rs, *fit_Rs_params), 
#  color=line_color, linewidth=1, linestyle='dashed')


                  

# Add individual circuit elements to slope plot
if plot_slopes == True:
  
  axs1.plot(v, 
      Diode_slope, 
      color=elements_line_color, linewidth=linewidth/1.5, linestyle='dashed')
    
  axs1.plot(v, 
      Tshunt_slope, 
      color=elements_line_color, linewidth=linewidth/1.5, linestyle=(0,(1,1)))
    
  axs1.plot(v, 
        Inj_slope, 
        color=elements_line_color, linewidth=linewidth/1.5, linestyle='dashdot')  
      
  axs1.plot(v, 
        Tseries_slope, 
        color=elements_line_color, linewidth=linewidth/2, linestyle=(2,(2,5,2))) 
      
  axs1.plot(v, 
        SC_slope, 
        color=elements_line_color, linewidth=linewidth/2, linestyle='dashdot') 

#  axs1.plot(v, 
#        Rseries_fit_slope, 
#        color=line_color, linewidth=linewidth, linestyle='dashed') 


            

          
# axs2.plot(v, 
#     Diode_curvature, 
#     color=line_color, linewidth=linewidth, linestyle='dashed')
# 
# axs2.plot(v, 
#     Tshunt_curvature, 
#     color=line_color, linewidth=linewidth, linestyle=(0,(1,1)))
# 
# axs2.plot(v, 
#       Inj_curvature, 
#       color=line_color, linewidth=linewidth, linestyle='dashdot')  
# 
# axs2.plot(v, 
#       Tseries_curvature, 
#       color=line_color, linewidth=linewidth/2, linestyle='dashdot') 
# 
# axs2.plot(v, 
#       SC_curvature, 
#       color=line_color, linewidth=linewidth/2, linestyle='dashdot') 
# 
# axs2.plot(v, 
#       Rseries_fit_curvature, 
#       color=line_color, linewidth=linewidth, linestyle='dashed') 
          

          



'''
Plot voltage drops
'''

if plot_voltage_curves == True:

  # Create scatter plot
  if black_background == True:
    plt.style.use('dark_background')							#black background
  fig2, ax = plt.subplots(dpi=dpi, layout='constrained')
  fig2.canvas.manager.set_window_title('Voltage drops') 

  # Add DataFrame data to plot
  for x in range(1,9):
    plt.plot(values[values.columns[0]].to_numpy(), values[values.columns[x]].to_numpy())

  # Add labels
  # last voltage value
  label_x = values[values.columns[0]].iat[-1] 
  y_offset = 0.06

  # label y values
  ax.text(label_x, values[values.columns[1]].iat[-1], values.columns[1]) 
  ax.text(label_x, values[values.columns[2]].iat[-1], values.columns[2]) 
  ax.text(label_x, values[values.columns[3]].iat[-1] - y_offset, values.columns[3]) 
  ax.text(label_x, values[values.columns[4]].iat[-1], values.columns[4]) 
  ax.text(label_x, values[values.columns[5]].iat[-1], values.columns[5]) 
  ax.text(label_x, values[values.columns[6]].iat[-1] - y_offset, values.columns[6]) 
  ax.text(label_x, values[values.columns[7]].iat[-1], values.columns[7]) 
  ax.text(label_x, values[values.columns[8]].iat[-1], values.columns[8]) 

  # Add fits to plot
  ax.plot(v, VRs_func(v, *fit_Rs_params), color=line_color, linestyle='dashed')
  ax.plot(Vr_fit_result, VRs_func(Vr_fit_result, *fit_Rs_params), marker='+', markersize=10)
  ax.text(Vr_fit_result-0.01, 
           VRs_func(Vr_fit_result, *fit_Rs_params)+0.05, '$V_{r}$', ha='right')
  ax.plot(v, Ip_func(v, *fit_Inj_params), color=line_color, linestyle='dashed')
  ax.plot(Vo_fit_result, Ip_func(Vo_fit_result, *fit_Inj_params), marker='+', markersize=10)
  ax.text(Vo_fit_result-0.01, 
           Ip_func(Vo_fit_result, *fit_Inj_params)+0.05, '$V_{0}$', ha='right')
  ax.plot(v, Diode_func(v, *fit_diode_params), color=line_color, linestyle='dashed')
  ax.plot(Vbi_fit_result, Diode_func(Vbi_fit_result, *fit_diode_params), marker='+', markersize=10)
  ax.text(Vbi_fit_result-0.01, 
           Diode_func(Vbi_fit_result, *fit_diode_params)+0.05, '$V_{bi}$', ha='right')





'''
Find coefficients in terms of effective voltage
'''


# Define fit power function
def fit_power(x, coef, power):
  return coef*np.power(x, power)

# Fit curves
fit_SC_eff_params, pcov = curve_fit(
          fit_power,
          SC_volt_drop,
          np.power(JoSC*SC_volt_drop/(SC_Vo+SC_d), sc)/A,
          p0=[1e4,2],
          method='lm'
)

fit_Ts_eff_params, pcov = curve_fit(
          fit_power, 
          Ts_volt_drop, 
          np.power(JoTs*Ts_volt_drop/(Ts_Vo+Ts_d), ts)/A,
          p0=[1e4,7],
          method='lm'
)
          
fit_Bsh_eff_params, pcov = curve_fit(
          fit_power, 
          block_shunt_volt_drop, 
          np.power(JoBsh*block_shunt_volt_drop/(Bsh_Vo+Bsh_d), bsh)/A,
          p0=[1e7,2],
          method='lm'
)

fit_Tsh_eff_params, pcov = curve_fit(
          fit_power, 
          Tsh_volt_drop, 
          np.power(JoTsh*Tsh_volt_drop/(Tsh_Vo+Tsh_d), tsh)/A,
          p0=[1e6,20],
          method='lm'
)
          
fit_Bd_eff_params, pcov = curve_fit(
          fit_power, 
          block_diode_volt_drop, 
          np.power(JoBd*block_diode_volt_drop/(Bd_Vo+Bd_d), bd)/A,
          p0=[1,2],
          method='lm'
)
          
# Create DataFrame
fit_eff_params = [fit_SC_eff_params[0], 
                  fit_Ts_eff_params[0], 
                  fit_Bsh_eff_params[0],
                  fit_Tsh_eff_params[0],
                  fit_Bd_eff_params[0]
]
                                
fit_eff_results_df = pd.DataFrame(index = [
  'JoSC_eff',
  'JoTs_eff', 
  'JoBsh_eff',
  'JoTsh_eff', 
  'JoBd_eff',
])

fit_eff_results_df['Value'] = fit_eff_params


# Add table of effective coefficients to plot
if write_parameter_values == True and plot_slopes == True:
  
  # remove column names from string
  fit_eff_results_string_temp = fit_eff_results_df.to_string()
  rows = fit_eff_results_string_temp.split('\n')
  rows.pop(0)
  fit_eff_results_string = '\n'.join(rows)
  
  # Add table of mobilities to plot
  axs1.text(0.02, 0.35, 
            fit_eff_results_string,   
            transform=axs1.transAxes, ha='left')









'''
Calculate mobility

# Searh folder name for thickness
#folder_name = files.name
#match = re.search(r'(..)nm', folder_name)
#thickness_C60 = int(match.group(1))

# Calculate mobility
def mobility(Jo_eff, thickness, epsilon):
  return 8/9*np.power(thickness*1e-9,3)/epsilon0/epsilon*Jo_eff

JoSC_eff = fit_eff_results.loc['JoSC_eff']
JoBsh_eff = fit_eff_results.loc['JoBsh_eff']
JoBd_eff = fit_eff_results.loc['JoBd_eff']

mobility_table = pd.DataFrame(index=[
  'mu_SC',
  'mu_Bsh'
  ], columns=['Value'])

mu_SC = mobility(JoSC_eff, thickness_MoO3, epsilon_C60)
mu_Bsh = mobility(JoBsh_eff, thickness_MoO3, epsilon_MoO3)

mobility_table.loc['mu_SC'] = mu_SC
mobility_table.loc['mu_Bsh'] = mu_Bsh

if write_parameter_values == True and plot_slopes == True:
  
  # remove column names from string
  mobility_table_string_temp = mobility_table.to_string()
  rows = mobility_table_string_temp.split('\n')
  rows.pop(0)
  mobility_table_string = '\n'.join(rows)
  
  # Add table of mobilities to plot
  axs1.text(0.02, 0.55, 
            mobility_table_string,   
            transform=axs1.transAxes, ha='left')
  
  # Add JoTs_eff to plot
  axs1.text(0.02, 0.35, 
            'JoTs_eff' + "  " + "{:.3g}".format(fit_eff_results.loc['JoTs_eff', 'Value']),   
            transform=axs1.transAxes, ha='left')
'''








'''
Plot effective voltage
'''


if plot_effective_voltage == True:

  # Create scatter plot
  if black_background == True:
    plt.style.use('dark_background')							#black background
  fig3, ax = plt.subplots(dpi=dpi, layout='constrained')
  fig3.canvas.manager.set_window_title('Effective voltage') 

  # Set up iv plot
  ax.set_ylabel("Current density [A/m$^2$]")
  ax.set_xlabel("Effective voltage [V]")
  ax.set_xscale("log")
  ax.set_yscale("log")
  ax.set_xlim(xmin=0.001)
  ax.set_ylim(ymin=0.00001, 
              ymax=3*np.power(JoSC*SC_volt_drop[-1]/(SC_Vo+SC_d), sc)/A)


  # Plot SC
  ax.plot(SC_volt_drop, 
          np.power(JoSC*SC_volt_drop/(SC_Vo+SC_d), sc)/A, 
          color='yellow')
  ax.text(SC_volt_drop[-1],
          np.power(JoSC*SC_volt_drop[-1]/(SC_Vo+SC_d), sc)/A,
          'SC_eff', ha='left')
  ax.plot(v, 
          np.power(JoSC*SC_volt_drop/(SC_Vo+SC_d), sc)/A, 
          color='yellow')
  ax.text(v[-1],
        np.power(JoSC*SC_volt_drop[-1]/(SC_Vo+SC_d), sc)/A,
        'SC', ha='left')

  # Plot Ts
  ax.plot(Ts_volt_drop, 
          np.power(JoTs*Ts_volt_drop/(Ts_Vo+Ts_d), ts)/A, 
          color='cyan')
  ax.text(Ts_volt_drop[-1],
          np.power(JoTs*Ts_volt_drop[-1]/(Ts_Vo+Ts_d), ts)/A,
          'Ts_eff', ha='left')
  ax.plot(v, 
          np.power(JoTs*Ts_volt_drop/(Ts_Vo+Ts_d), ts)/A, 
          color='cyan')
  ax.text(v[-1],
        np.power(JoTs*Ts_volt_drop[-1]/(Ts_Vo+Ts_d), ts)/A,
        'Ts', ha='left')
      
  # Plot Bsh
  ax.plot(block_shunt_volt_drop, 
          np.power(JoBsh*block_shunt_volt_drop/(Bsh_Vo+Bsh_d), bsh)/A, 
          color='red')
  ax.text(block_shunt_volt_drop[-1],
          np.power(JoBsh*block_shunt_volt_drop[-1]/(Bsh_Vo+Bsh_d), bsh)/A,
          'Bsh_eff', ha='left')
  ax.plot(v, 
          np.power(JoBsh*block_shunt_volt_drop/(Bsh_Vo+Bsh_d), bsh)/A, 
          color='red')
  ax.text(v[-1],
          np.power(JoBsh*block_shunt_volt_drop[-1]/(Bsh_Vo+Bsh_d), bsh)/A,
          'Bsh', ha='left')

  # Plot Tsh
  ax.plot(Tsh_volt_drop, 
          np.power(JoTsh*Tsh_volt_drop/(Tsh_Vo+Tsh_d), tsh)/A, 
          color='red')
  ax.text(Tsh_volt_drop[-1],
          np.power(JoTsh*Tsh_volt_drop[-1]/(Tsh_Vo+Ts_d), tsh)/A,
          'Tsh_eff', ha='left')
  ax.plot(v, 
          np.power(JoTsh*Tsh_volt_drop/(Tsh_Vo+Tsh_d), tsh)/A, 
          color='red')
  ax.text(v[-1],
          np.power(JoTsh*Tsh_volt_drop[-1]/(Tsh_Vo+Ts_d), tsh)/A,
          'Tsh', ha='left')
        
  # Plot Bd
  ax.plot(block_diode_volt_drop, 
          np.power(JoBd*block_diode_volt_drop/(Bd_Vo+Bd_d), bd)/A, 
          color='red')
  ax.text(block_diode_volt_drop[-1],
          np.power(JoBd*block_diode_volt_drop[-1]/(Bd_Vo+Bd_d), bd)/A,
          'Bd_eff', ha='left')
  ax.plot(v, 
          np.power(JoBd*block_diode_volt_drop/(Bd_Vo+Bd_d), bd)/A, 
          color='red')
  ax.text(v[-1],
          np.power(JoBd*block_diode_volt_drop[-1]/(Bd_Vo+Bd_d), bd)/A,
          'Bd', ha='left')



  # Plot fit
  ax.plot(SC_volt_drop, 
          fit_power(SC_volt_drop, *fit_SC_eff_params), linestyle="dashed",
          color=line_color)  
  
  ax.plot(Ts_volt_drop, 
          fit_power(Ts_volt_drop, *fit_Ts_eff_params), linestyle="dashed",
          color=line_color)

  ax.plot(block_shunt_volt_drop, 
        fit_power(block_shunt_volt_drop, *fit_Bsh_eff_params), linestyle="dashed",
        color=line_color)

  ax.plot(Tsh_volt_drop, 
          fit_power(Tsh_volt_drop, *fit_Tsh_eff_params), linestyle="dashed",
          color=line_color)
        
  ax.plot(block_diode_volt_drop, 
        fit_power(block_diode_volt_drop, *fit_Bd_eff_params), linestyle="dashed",
        color=line_color)

  if write_parameter_values == True:
  
    # Add table of parameters to plot
    ax.text(0.02, 0, 
              fit_eff_results_df.to_string(),   
              transform=ax.transAxes, ha='left')





'''
Save all parameters
'''
    
# Gathering all parameters into a single DataFrame
all_results_df = pd.concat([fit_volt_results_df, 
                            circuit_parameters_df, 
                            error_results_df,
                            fit_eff_results_df
])

print(all_results_df)
                          
if save_fit_branches == True:
  
  # check if file exits
  filename = Path(folderpath/'Fit values .txt')
  i = 1
  while (new_filename := filename.with_stem(f"{filename.stem}{i}")).exists():
    i += 1
    
  # save curve
  all_results_df.to_csv(new_filename, sep='\t', index=False)
  
  print('Parameters Saved')
  
  

plt.show()